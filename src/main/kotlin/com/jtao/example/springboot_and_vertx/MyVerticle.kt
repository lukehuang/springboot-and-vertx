package com.jtao.example.springboot_and_vertx

import io.netty.handler.codec.mqtt.MqttQoS
import io.vertx.core.AbstractVerticle
import io.vertx.core.Vertx
import io.vertx.core.buffer.Buffer
import io.vertx.core.json.JsonObject
import io.vertx.core.net.NetClientOptions
import io.vertx.core.net.NetServerOptions
import io.vertx.core.net.NetSocket
import io.vertx.ext.mongo.MongoClient
import io.vertx.ext.web.Router
import io.vertx.mqtt.MqttClient
import io.vertx.mqtt.MqttClientOptions
import org.slf4j.LoggerFactory
import java.util.*

class MyVerticle(
        val tcpPort:Int = 12345,
        val webPort:Int = 8080,
        val monitorDbHost:String = "111.230.197.145",
        val yunkongHost:String = "106.15.56.97",
        val yunkongPort:Int = 8989,
        val mqttHost:String = "111.230.197.145",
        val mqttPort:Int = 1883
): AbstractVerticle() {

    private val log = LoggerFactory.getLogger(MyVerticle::class.java)!!

    private val socketList = ArrayList<NetSocket>()

    override fun start() {
        val vertx = Vertx.vertx()
        val eb = vertx.eventBus()

        //配置Tcp选项：KeepAlive
        val serverOption = NetServerOptions().setTcpKeepAlive(true)
        val server = vertx.createNetServer(serverOption)

        val httpclient = vertx.createHttpClient()

        //配置监控数据库
        val dbConfig = JsonObject()
                .put("db_name", "monitor_new_2")
                .put("host", monitorDbHost)
        val db = MongoClient.createNonShared(vertx, dbConfig)

        //配置WebSocket实时监控页面
        val webserver = vertx.createHttpServer()
        val router = Router.router(vertx)
        router.route("/").handler { routingContext -> routingContext.response().sendFile("html/ws.html") }
        webserver
                .requestHandler(router::accept)
                .websocketHandler { webSocket->
                    eb.consumer<String>("receive tcp message", {message ->
                        webSocket?.writeFinalTextFrame(message.body())
                    })
                    eb.consumer<String>("websocket publish", {message ->
                        webSocket?.writeFinalTextFrame(message.body())
                    })
                    webSocket?.exceptionHandler{}
                    webSocket?.closeHandler {}
        }.listen(webPort)
        log.info("web port: $webPort")

        // 连接至远程服务器
        val tcpClientOptions = NetClientOptions().setReconnectAttempts(10).setReconnectInterval(500)
        val tcpClient = vertx.createNetClient(tcpClientOptions)
        var clientSocket:NetSocket? = null
        tcpClient.connect(yunkongPort, yunkongHost, {res->
            if(res.succeeded()) {
                log.info("connect to server")
                clientSocket = res.result()
            }
            else {
                log.info("connect error")
            }
        })

        //连接至MQTT服务器
        val mqttOptions = MqttClientOptions()
        mqttOptions.isAutoGeneratedClientId = true
        mqttOptions.isAutoKeepAlive = true
        val mqttclient = MqttClient.create(vertx, mqttOptions)
        mqttclient.connect(mqttPort,mqttHost,{
            if (it.succeeded()){
                mqttclient.publishHandler { event->
                    var b = byteArrayOf(
                            0x00,0x00,0x00,
                            0xff.toByte(), 0xfe.toByte(),0x00,
                            0x24,0x00
                    )
                    val m = event.payload().toString()
                    println(m)
                    val o = event.payload().toJsonObject()
                    b[0] = o.getInteger("addr0").toByte()
                    b[1] = o.getInteger("addr1").toByte()
                    b[2] = o.getInteger("channel").toByte()
                    b[5] = b[2]
                    socketList.forEach{
                        it.write(Buffer.buffer(b))
                    }
                }.subscribe("sensor", 1)

                mqttclient.publishHandler { event->
                    var b = byteArrayOf(
                            0x00,0x00,0x00,
                            0xff.toByte(), 0xfe.toByte(),0x00,
                            0x28,0x00
                    )
                    val m = event.payload().toString()
                    println(m)
                    val o = event.payload().toJsonObject()
                    b[0] = o.getInteger("addr0").toByte()
                    b[1] = o.getInteger("addr1").toByte()
                    b[2] = o.getInteger("channel").toByte()
                    b[5] = b[2]
                    socketList.forEach{
                        it.write(Buffer.buffer(b))
                    }
                }.subscribe("gps", 1)
            } else {
                println(it.cause())
            }
        })

        //处理连接上来的socket
        server.connectHandler { socket ->
            socketList.add(socket)
            log.info("${socket.remoteAddress()} connect")
            eb.publish("receive tcp message", "${socket.remoteAddress()} connected")

            var ismqttconnect = false

            socket.handler { msg ->
                val m = msg.bytes

                // 获取网关信道
                if(msg.length() > 3) {
                    log.info("Date: ${Date()} Socket: ${socket.remoteAddress()} Message: ${m.toHexString()}")

                    /*
                    // 配置MQTT订阅
                    if (!ismqttconnect){
                        channel = (m[2].toInt() +256)%256
                        val bs_channel = byteArrayOf(m[2])
                        s_channel = bs_channel.toHexString()
                        mqttclient.publishHandler {event ->
                            println("topic: ${event.topicName()}")
                            println("content: ${event.payload()}")
                            val b = byteArrayOf(
                                    0x05,
                                    0xff.toByte(), 0xff.toByte(),0x00,
                                    0xff.toByte(), 0xfe.toByte(),0x00,
                                    0x26,0x01, 0x81.toByte())
                            val o = event.payload().toJsonObject()
                            log.info("mqtt receive $o")

                            b[1] = o.getString("addr0").toByte(16)
                            b[2] = o.getString("addr1").toByte(16)
                            b[3] = o.getString("channel").toByte(16)
                            when(o.getString("ctrl")){
                                "on"-> {
                                    b[9] = 0x81.toByte()
                                    socket.write(Buffer.buffer(b))
                                }
                                "off"->{
                                    b[9] = 0x80.toByte()
                                    socket.write(Buffer.buffer(b))
                                }
                            }
                        }.subscribe("valve/$s_channel",2)
                        ismqttconnect = true
                        println("mqtt sub valve/$s_channel")
                    }
                    */

                    val l = JsonObject()
                    l.put("Date", Date().toLocaleString()).put("timestamp", Date().time).put("socket", socket.remoteAddress().toString()).put("message", m.toHexString())
                    db?.insert("log", l, {
                        if (it.succeeded()) log.info("Insert db succeed. ${it.result()}")
                        else log.info("Insert db error.")
                    })

                    val addr = (((m[0]+256)%256)*256 + (m[1]+256)%256)
                    var s_addr = addr.toString(16)
                    repeat(4-s_addr.length, {i: Int -> s_addr="0$s_addr" })

                    val channel = ((m[2]+256)%256)
                    var s_channel = channel.toString(16)
                    if(s_channel.length <2){
                        s_channel = "0$s_channel"
                    }

                    val endpoint = Endpoint(addr, channel)
                    if(Endpoints.find(endpoint) == null){
                        Endpoints.save(endpoint, EndpointData(0,0,"00000.0000","0000.0000"))
                    }

                    val id = "010203040506070809$s_addr$s_channel"

                    //处理温湿度数据
                    if ((m.size == 9) and (m[3] == 0x25.toByte())) {
                        val tem = m[5] * 256 + m[6]
                        val hum = m[7] * 256 + m[8]
                        var s_t = "$tem"
                        while (s_t.length < 4) {
                            s_t = "0$s_t"
                        }
                        var s_h = "$hum"
                        while (s_h.length < 4) {
                            s_h = "0$s_h"
                        }
                        log.info("temperature = $s_t, humidity = $s_h")

                        val j = JsonObject()
                                .put("timestamp", Date().time)
                                .put("addr", s_addr)
                                .put("channel", s_channel)
                                .put("温度", tem )
                                .put("湿度", hum )
                        db?.insert("sensor", j, {})
                        eb.publish("websocket publish", """${Date()},${s_addr}${s_channel},温度:$s_t,湿度:$s_h""")

                        mqttclient.publish("sensor",
                                JsonObject().put("addr",s_addr).put("channel",s_channel).put("temperature", tem).put("humidity", hum).toBuffer(),
                                MqttQoS.EXACTLY_ONCE,
                                false,
                                false)

                        Endpoints.save(endpoint, Endpoints.find(endpoint)!!.copy(humidity = hum, temperature = tem))
                    }

                    // 处理gps数据
                    if (m[3] == 0x29.toByte()) {
                        var jingdu = ""
                        var weidu=""
                        var s_gps = "400e0c8e0d0d${s_addr}${s_channel}${id}1d${jingdu}${weidu}"
                        m.copyOfRange(5, 15).forEach {
                            it.toChar()
                            jingdu = jingdu+it.toChar()
                        }
                        m.copyOfRange(15, 24).forEach {
                            weidu = weidu+it.toChar()
                        }
//                        val jingdu_dec = jingdu.substring(0,2)
//                        println(jingdu_dec)
//                        val jingdu_min = (jingdu.substring(3,5)+jingdu.substring(6)).toLong()
//                        println(jingdu_min)
//                        jingdu = "${jingdu_dec}.${jingdu_min/60}".substring(0,9)
//
//                        val weidu_dec = weidu.substring(0,1)
//                        println(weidu_dec)
//                        val weidu_min = (weidu.substring(2,4)+weidu.substring(5)).toLong()
//                        println(weidu_min)
//                        weidu = "${weidu_dec}.${weidu_min/60}".substring(0,8)
//                        println(jingdu+weidu)
                        log.info("gps: ${jingdu},${weidu}")
                        //clientSocket?.write(s_gps)
                        log.info("send to server: $s_gps")
                        db?.insert("gps",
                                JsonObject()
                                        .put("timestamp", Date().time)
                                        .put("addr", s_addr)
                                        .put("channel", s_channel)
                                        .put("经度", jingdu)
                                        .put("纬度", weidu),
                                {})

                        Endpoints.save(endpoint, Endpoints.find(endpoint)!!.copy(latitude = weidu, longitide = jingdu))
                        eb.publish("websocket publish", """${Date()},${s_addr}${s_channel},经度:$jingdu,纬度:$weidu""")

                        mqttclient.publish("sensor",
                                JsonObject().put("addr",s_addr).put("channel",s_channel).put("jingdu", jingdu).put("weidu", weidu).toBuffer(),
                                MqttQoS.EXACTLY_ONCE,
                                false,
                                false)
                    }

                    val endpointData = Endpoints.find(endpoint)
                    val jingdu = endpointData!!.longitide
                    val weidu = endpointData!!.latitude
                    val wendu = endpointData!!.temperature
                    val shidu = endpointData!!.humidity
                    var w_s = wendu.toString()
                    repeat(4-w_s.length, {w_s = "0$w_s"})
                    println(w_s)
                    var s_s = shidu.toString()
                    repeat(4-s_s.length, {s_s = "0$s_s"})
                    println(s_s)
                    val s_sensor="461232140f10$id$s_addr$s_channel${jingdu}0$weidu$w_s$s_s"
                    println(s_sensor)
                    clientSocket?.write(s_sensor)
//                    httpclient.post("http://106.15.56.97:8899/wlw/equipment/receive",{
//                        log.info(it.statusMessage())
//                    }).end(s_sensor)

                }
            }

            socket.closeHandler {
                log.info("${socket.remoteAddress()} closed")
                //eb.publish("receive tcp message", "${socket.remoteAddress()} closed")
//                mqttclient.unsubscribe("valve/00")
            }

            socket.exceptionHandler{
                log.info("${socket.remoteAddress()} error")
            }
        }

        server.listen(tcpPort)
        log.info("MyVerticle listen on $tcpPort")
    }
}